

举例：假设原数值为
x = 1011 1001 011 ，p=6，n=4

直观感觉，首先“中间的n位”需要取反，然后其余位不变，怎么运算会不变，第一个出现在脑海里的是和1做&操作。所以如果能搞出下面两个数，进行与操作，那么就达成目的了！
A = 1111（中间已经取反的n位）111
B = 去除中间位的高位原值 （中间n为都是1）去除中间为的低位原值

最后的结果就是 A & B

那么怎么得到A？

根据教材中的例子，可以把x 进行右移操作，把要操作的中间4位移到后面去，得到

a1 = x >> (p-n+1) = 000 1011 1001

然后，对这个值取反，得到中间n位的反码

a2 = ~a1 = 111 0100 0110

然后，把除过（~）最低4位的其余所有位置为1，利用 | 的属性，当然这个值set_high要根据逻辑进行运算，这里得到 set_low其实就是 移动距离宽度位都是1对应的10进制数，本例子中111 就是 7

a3 = ~set_high | a2 = 111 1111 0110

然后我们再把后面这4个值移动回到原来的位置上

a4 = a3 << (p-n+1) = 1111 0110 000

然后再把最低位的移动距离对应的0都置为1，就得到了A

A = a5 = a4 | set_low = 1111 0110 111

距离成功，已经走了一半路了！！！！！接下来计算B。

那么B其实更简单，只是想把指定位置的指定位宽值都置为1，根据 | 的属性，可以计算一个 set_mid 值，来达到目的。 比如这个例子中的set_mid = 1111 000 ，就是120

B = x | set_mid

最终结果就出来了 

return A & B

